### 并发一致性问题和解决方法

| 问题 | 说明 | 举例 | 解决方法 | 封锁级别 | 隔离级别 |
| ---- | ---- | ---- | ---- | ---- | ---- | 
| 丢失修改 | 一个事务的更新操作被另外一个事务的更新操作替换 | T1和T2两个事务都对一个数据进行修改，T1先修改并提交生效，T2随后修改，T2的修改覆盖了T1的修改 | 加写锁（X锁），使得两个写操作不能同时进行（防止了先写，再写） | 一级封锁协议 | 未提交读（事务中的修改，即使没有提交，对其他事务也是可见的）
| 读脏数据 | 在不同的事务下，当前事务可以读到另外事务未提交的数据 | T1修改了一个数据但未提交，T2随后读取这个数据，如果T1撤销了这次修改，那么T2读取的数据是脏数据 | 加读锁（S锁），使得读写操作不能同时进行（防止了先写，再读） | 二级封锁协议 | 提交读（一个事务所做的修改在提交之前对其它事务是不可见的）
| 不可重复读 | 一个事务内多次读取同一数据集合，在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一个事务的两次读取的数据可能不一致 | T2读取一个数据，T1对该数据做了修改，如果T2再次读取这个数据，此时读取的结果和第一次读取的结果不同 | 在二级封锁协议的基础上，读操作结束后不立刻释放读锁，直到事务结束再释放（防止了先读、再写、再读） | 三级封锁协议 | 可重复读（保证在同一个事务中多次读取一个数据的结果是一样的）
| 幻影读 | 本质也属于不可重复读的情况 | T1读取某个范围的数据，T2在这个范围内插入新的数据，T1再次读取这个范围的数据，此时读取的结果和第一次读取的结果不同 | 加间隙锁（锁定索引之间的间隙）| / | /


### 写锁（X锁）和读锁（S锁）

- 互斥锁（Exclusive），简写为X锁，又称写锁
- 共享锁（Shared），简写为S锁，又称读锁

- 当

### 行级锁、表级锁、意向锁

- 对表中的某一行（某一条记录）加锁，就是行级锁
- 对表中的每一行加锁，就是表级锁
- 当事务想对表加表级锁时，需要先检测表的每一行是否已经有行级锁，如果都没有行级锁，才能加上表级锁，这个检测过程是非常耗时的，意向锁就是用于解决这个问题
- 当表中的任意一行加了行级锁，这个表就加了意向锁，那么当事务想对表加表级锁时，只需要检查是否存在意向锁，节省了很多检测时间
- 