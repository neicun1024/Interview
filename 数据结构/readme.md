## 主要记录了一些印象不深的数据结构的内容

### 红黑树
#### 红黑树的特性：
1. 每个节点是红色或黑色
2. 根节点是黑色
3. 每个叶子节点是黑色（*这里的叶子节点指空的叶子节点*）
4. 如果一个节点是红色的，则它的子节点必须是黑色的
5. 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点

#### 红黑树的调整
* 变色
* 左旋
* 右旋

#### 红黑树为什么快？
红黑树的查询性能略微逊色于AVL树，因为他比avl树会稍微不平衡最多一层，也就是说红黑树的查询性能只比相同内容的avl树最多多一次比较，但是，红黑树在插入和删除上完爆avl树，avl树每次插入删除会进行大量的平衡度计算，而红黑树为了维持红黑性质所做的红黑变换和旋转的开销，相较于avl树为了维持平衡的开销要小得多

#### 红黑树和AVL树的区别

1. AVL树是严格平衡的二叉树，所有节点的左右子树高度差的绝对值不超过1，而红黑树是非严格平衡的，
2. 红黑树的插入删除的效率高，它的任何不平衡都会在三次旋转之内解决，AVL树的查找效率高
3. 红黑树的统计性能高于AVL树



### map和unordered_map的区别

#### 底层实现
- map：红黑树，具有自动排序的功能，元素是有序的
- unordered_map：哈希表，元素是无序的

#### 优缺点及适用处
- map：
  - 优点：
    - 有序性，红黑树使得map的增删改的时间复杂度均为log<sub>2</sub>n，效率非常高
  - 缺点：
    - 空间占用率高，红黑树的每个节点都需要额外保存父节点，孩子节点以及红/黑的性质
  - 适用处：
    - 有顺序要求的问题
- unordered_map
  - 优点：
    - 因为内部实现了哈希表，因此查找速度非常快
  - 缺点：
    - 哈希表的建立比较耗费时间
  - 适用处：
    - 查找问题

*对于unordered_map或者unordered_set容器，其遍历顺序与创建该容器时输入元素的顺序是不一定一致的，遍历是按照哈希表从前往后依次遍历的*


### hash_map

#### 原理：
- hash_map基于hash_table（哈希表）

- 使用一个下标范围比较大的数组来存储元素，同时设计一个哈希函数（也叫散列函数），使得每个元素的key都与一个函数值相对应（即哈希值对应了数组下标），于是用这个数组下标对应的位置来存储这个元素；可以简单理解为，按照key为每个元素“分类”，然后将这个元素存储在这个“类别”对应的地方，称为**桶**；

- 但是，不能保证每个元素的key与函数值是一一对应的，因此可能出现对于不同的元素，计算出相同的函数值，这样就产生了冲突；

- **直接定址**和**解决冲突**是哈希表的两大特点

#### hash_map的插入和取值过程

- 插入过程：

  1. 得到key
  2. 通过哈希函数得到哈希值
  3. 得到桶号（一般为哈希值对桶数求模）
  4. 存放key和value在桶内

- 取值过程：

  1. 得到key
  2. 通过哈希函数得到哈希值
  3. 得到桶号（一般为哈希值对桶数求模）
  4. 比较桶的内部元素是否与key相等，若都不相等，则没有找到
  5. 取出key相等的记录的value


### B树

B树也叫B-树，是一颗多路自平衡查找树

#### B树的定义：
- 每个节点最多有m-1个关键字（可以存有的键值对）
- 根节点最少可以只有1个关键字
- 非根节点至少有m/2个关键字
- 每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它
- 所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同
- 每个节点都存有索引和数据，也就是对应的key和value
  
  所以，根节点的关键字数量范围：1 <= k <= m-1，非根节点的关键字数量范围：m/2 <= k <= m-1；

  其中，m表示B树的阶数；

### B+树

#### 和B树的相同点
- 根节点至少一个元素
- 非根节点元素范围：m/2 <= k <= m-1

#### 和B数的不同点
- B+树有两种类型的节点：内部结点（也称索引结点）和叶子结点。内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存储在叶子节点。
- 内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。
- 每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。
- 父节点存有右孩子的第一个元素的索引。

#### B+树相比B树的优势
- 单一节点存储的元素更多，使得查询的IO次数更少，所以也就使得它更适合做为数据库MySQL的底层数据结构了
- 所有的查询都要查找到叶子节点，查询性能是稳定的，而B树，每个节点都可以查找到数据，所以不稳定
- 所有的叶子节点形成了一个有序链表，更加便于查找

#### B+树相比红黑树的优势
- B+ 树有更低的树高
  - 平衡树的树高 O(h)=O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多
- 磁盘访问原理
  - 操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点
  - 如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+ 树相对于红黑树有更低的树高，进行寻道的次数与树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以 B+ 树更适合磁盘数据的读取
- 磁盘预读特性
  - 为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入

