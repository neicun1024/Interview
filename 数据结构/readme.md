# 这里记录了数据结构相关的内容

## 红黑树
### 红黑树的特性：
1. 每个节点是红色或黑色
2. 根节点是黑色
3. 每个叶子节点是黑色（*这里的叶子节点指空的叶子节点*）
4. 如果一个节点是红色的，则它的子节点必须是黑色的
5. 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点

### 红黑树的调整
* 变色
* 左旋
* 右旋

### 红黑树为什么快？
红黑树的查询性能略微逊色于AVL树，因为他比avl树会稍微不平衡最多一层，也就是说红黑树的查询性能只比相同内容的avl树最多多一次比较，但是，红黑树在插入和删除上完爆avl树，avl树每次插入删除会进行大量的平衡度计算，而红黑树为了维持红黑性质所做的红黑变换和旋转的开销，相较于avl树为了维持平衡的开销要小得多

### 红黑树和AVL树的区别

1. AVL树是严格平衡的二叉树，所有节点的左右子树高度差的绝对值不超过1，而红黑树是非严格平衡的，
2. 红黑树的插入删除的效率高，它的任何不平衡都会在三次旋转之内解决，AVL树的查找效率高
3. 红黑树的统计性能高于AVL树



## map和unordered_map的区别

### 底层实现
- map：红黑树，具有自动排序的功能，元素是有序的
- unordered_map：哈希表，元素是无序的

### 优缺点及适用处
- map：
  - 优点：
    - 有序性，红黑树使得map的增删改的时间复杂度均为log<sub>2</sub>n，效率非常高
  - 缺点：
    - 空间占用率高，红黑树的每个节点都需要额外保存父节点，孩子节点以及红/黑的性质
  - 适用处：
    - 有顺序要求的问题
- unordered_map
  - 优点：
    - 因为内部实现了哈希表，因此查找速度非常快
  - 缺点：
    - 哈希表的建立比较耗费时间
  - 适用处：
    - 查找问题

*对于unordered_map或者unordered_set容器，其遍历顺序与创建该容器时输入元素的顺序是不一定一致的，遍历是按照哈希表从前往后依次遍历的*


## hash_map

### 原理：
- hash_map基于hash_table（哈希表）

- 使用一个下标范围比较大的数组来存储元素，同时设计一个哈希函数（也叫散列函数），使得每个元素的key都与一个函数值相对应（即哈希值对应了数组下标），于是用这个数组下标对应的位置来存储这个元素；可以简单理解为，按照key为每个元素“分类”，然后将这个元素存储在这个“类别”对应的地方，称为**桶**；

- 但是，不能保证每个元素的key与函数值是一一对应的，因此可能出现对于不同的元素，计算出相同的函数值，这样就产生了冲突；

- 哈希函数取模一般取质数，因为这样key和模的最大公因数为1，能够减少冲突的可能性；

- **直接定址**和**解决冲突**是哈希表的两大特点

### hash_map的插入和取值过程

- 插入过程：

  1. 得到key
  2. 通过哈希函数得到哈希值
  3. 得到桶号（一般为哈希值对桶数求模）
  4. 存放key和value在桶内

- 取值过程：

  1. 得到key
  2. 通过哈希函数得到哈希值
  3. 得到桶号（一般为哈希值对桶数求模）
  4. 比较桶的内部元素是否与key相等，若都不相等，则没有找到
  5. 取出key相等的记录的value

### [解决哈希冲突的方法](https://cloud.tencent.com/developer/article/1672781)
1. 开放定址法
   - 从发生冲突的单元起，按一定次序，从哈希表中找到一个空闲的单元
   - 包括：
     1. 线性探查法
     2. 平方探查法
     3. 双散列函数探查法
2. 链地址法
   - 将哈希值相同的元素构成一个单链表，并将链表的头指针放在哈希表中
3. 再哈希法
   - 同时构造多个不同的哈希函数，当发生冲突时，用下一个哈希函数，直到不产生冲突为止
   - 不容易产生聚集，但是增加了计算时间 

## B树

B树也叫B-树，是一颗多路自平衡查找树

#### B树的定义：
- 每个节点最多有m-1个关键字（可以存有的键值对）
- 根节点最少可以只有1个关键字
- 非根节点至少有m/2个关键字
- 每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它
- 所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同
- 每个节点都存有索引和数据，也就是对应的key和value
  
  所以，根节点的关键字数量范围：1 <= k <= m-1，非根节点的关键字数量范围：m/2 <= k <= m-1；

  其中，m表示B树的阶数；

## B+树

### 和B树的相同点
- 根节点至少一个元素
- 非根节点元素范围：m/2 <= k <= m-1

### 和B数的不同点
- B+树有两种类型的节点：内部结点（也称索引结点）和叶子结点。内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存储在叶子节点。
- 内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。
- 每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。
- 父节点存有右孩子的第一个元素的索引。

### B+树相比B树的优势
- 单一节点存储的元素更多，使得查询的IO次数更少，所以也就使得它更适合做为数据库MySQL的底层数据结构了
- 所有的查询都要查找到叶子节点，查询性能是稳定的，而B树，每个节点都可以查找到数据，所以不稳定
- 所有的叶子节点形成了一个有序链表，更加便于查找

### B+树相比红黑树的优势
- B+ 树有更低的树高
  - 平衡树的树高 O(h)=O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多
- 磁盘访问原理
  - 操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点
  - 如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+ 树相对于红黑树有更低的树高，通常进行磁盘IO的次数与树高成正比，所以 B+ 树更适合磁盘数据的读取
- 磁盘预读特性
  - 为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入


## STL

- vector
    - 数据结构
        - 连续线性空间
    - 内存申请方式
        - 当size==capacity时，会申请更大的空间，并将旧空间中的数据移到新的内存空间中，最后将旧的空间释放
- map和set
    - 数据结构
        - 红黑树
    - 为何map和set的插入删除效率比其它序列容器高？
        - 所有元素以节点方式存储，操作都是针对指针，不需要做内存拷贝和内存移动
- deque
    - 数据结构
        - 由一段一段等长的连续空间构成，各段空间之间不一定连续
        - 用一个数组存储各个连续空间的首地址
    - 内存申请方式
        - 当所有连续空间满了后，就申请一段新的连续空间，同时在数组中存储这个空间的首地址
        - 如果存首地址的数组满了，就用和vector相同的申请方式
- list
    - 数据结构
        - 双向循环链表
- queue和stack都是通过deque实现的


## Java中HashMap和HashTable的区别

HashMap 不是线程安全的

HashMap 是 map 接口的实现类，是将键映射到值的对象，其中键和值都是对象，并且不能包含重复键，但可以包含重复值。HashMap 允许 null key 和 null value，而 HashTable 不允许。

HashTable 是线程安全的

HashMap 是 HashTable 的轻量级实现，他们都完成了Map 接口，主要区别在于 HashMap 允许 null key 和 null value，由于非线程安全，效率上可能高于 Hashtable。

区别：
- HashMap允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。
- HashMap 把 Hashtable 的 contains 方法去掉了，改成 containsValue 和 containsKey。因为 contains 方法容易让人引起误解。
- HashTable 继承自 Dictionary 类，而 HashMap 是 Java1.2 引进的 Map interface 的一个实现。
- HashTable 的方法是 Synchronize 的，而 HashMap 不是，在多个线程访问 Hashtable 时，不需要自己为它的方法实现同步，而 HashMap 就必须为之提供外同步。
- Hashtable 和 HashMap 采用的 hash/rehash 算法都大概一样，所以性能不会有很大的差异。


