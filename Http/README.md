# 这里存放了Http和Https相关内容


## SSL证书

### [证书的签发过程](https://www.cnblogs.com/xdyixia/p/11610102.html)

![20220413102628](https://raw.githubusercontent.com/neicun1024/PicBed/main/images_for_markdown/20220413102628.png)

1. 服务器S向第三方机构CA提交公钥、组织信息、个人信息（域名）等信息并申请认证；
2. CA通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名等所有权等；
3. 如信息审核通过，CA会向申请者签发认证文件：证书；

**证书包含的信息：**

申请者公钥、申请者的组织信息和个人信息、签发机构CA的信息、有效时间、证书序列号等信息的明文，同时包含一个签名；

签名的产生算法：首先使用散列函数计算公开的明文信息的信息摘要，然后采用CA的私钥（CA机构也生成了密码对，和服务器S生成的密码对不同）对信息摘要进行加密，密文即签名；

4. 客户端C向服务器S发出请求时，S返回证书文件；
5. 客户端C读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应CA的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即公钥合法；
6. 客户端C然后验证证书相关的域名信息、有效时间等信息；
7. 客户端C会内置信任CA的证书信息(包含公钥)，如果CA不被信任，则找不到对应CA的证书，证书也会被判定非法；

**注意：**
1. 申请证书不需要提供私钥，确保私钥永远只能服务器掌握；
2. 证书的合法性仍然依赖于非对称加密算法，证书主要是增加了服务器信息以及签名；
3. 内置 CA 对应的证书称为根证书，颁发者和使用者相同，自己为自己签名，即自签名证书（为什么说"部署自签SSL证书非常不安全"）
4. 证书 = 公钥（服务方生成密码对中的公钥） + 申请者与颁发者信息 + 签名（用CA机构生成的密码对的私钥进行签名）；


### [https的通信过程](https://blog.csdn.net/u010164190/article/details/104582419)

![20220413104007](https://raw.githubusercontent.com/neicun1024/PicBed/main/images_for_markdown/20220413104007.png)

1. 客户端发送请求到服务器端;
2. 服务器端返回证书和公开密钥，公开密钥作为证书的一部分而存在;
3. 客户端验证证书和公开密钥的有效性，如果有效，则生成共享密钥并使用公开密钥加密发送到服务器端;
4. 服务器端使用私有密钥解密数据，并使用收到的共享密钥加密数据，发送到客户端;
5. 客户端使用共享密钥解密数据;
6. SSL加密建立......


### 浏览器CA认证流程

1. 客户端向一个需要https访问的网站发起请求；
2. 服务器将证书发送给客户端进行校验。证书里面包含了其公钥。这里要特别说一下客户端到底 如何来校验对方发过来的数字证书是否有效：
   1. 首先在本地电脑寻找是否有这个服务器证书上的ca机构的根证书。如果有继续下一步，如果没有弹出警告；
   2. 使用CA机构根证书的公钥对服务器证书的指纹和指纹算法进行解密；
   3. 得到指纹算法（散列函数）之后，用这个指纹算法对服务器证书的摘要进行计算得到指纹；
   4. 将计算出的指纹和从服务器证书中解密出的指纹对比看是否一样如果一样则通过认证；
3. 校验成功之后，客户端会生成一个随机串然后使用服务器证书的公钥进行加密之后发送给服务器；
4. 服务器通过使用自己的私钥解密得到这个随机值；
5. 服务器从此开始使用这个随机值进行对称加密开始和客户端进行通信；
6. 客户端拿到值用对称加密方式 使用随机值进行解密；


### 特点

1. 非对称加密的消耗和所需的计算以及时间远比对称加密消耗要大，所以在握手和认证之后，服务器和客户端就开始按照约定的随机串，对后续的数据传输进行加密；
2. 非对称加密算法对加密内容的长度有限制；
3. 非对称加密相比对称加密更加安全；
4. CA数字证书作用之一是公钥分发；
5. 数字签名的签发过程是私钥加密，公钥解密；