## 主要记录了操作系统相关知识

### 进程与线程
* 进程是资源分配的基本单位
* 线程是CPU调度的基本单位

### 进程之间的通信方式以及优缺点
* 管道(PIPE)：
    * 有名管道：一种半双工的通信方式，允许无亲缘关系进程间的通信
        * 优点：可以实现任意关系的进程间的通信
        * 缺点：
            1. 长期存在于系统中，使用不当容易出错
            2. 缓冲区有限
    * 匿名管道：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程）
        * 优点：简单方便
        * 缺点：
            1. 局限于单向通信
            2. 只能创建在它的进程以及其有亲缘关系的进程之间
            3. 缓冲区有限
* 消息队列(Message Queue)：是消息的链表，存放在内核中并由消息队列标识符标识 
    * 和管道的对比：
        1. 匿名管道是跟随进程的，消息队列是跟随内核的，进程结束之后，匿名管道就死了，但是消息队列还会存在（除非显示调用函数销毁）
        2. 管道是文件，存放在磁盘上，访问速度慢，消息队列是数据结构，存放在内存，访问速度快
        3. 管道是数据流式存取，消息队列是数据块式存取
    * 优点：
        1.  对于交换少量数量的数据很有用，因为无需冲突避免
        2.  对于分布式系统，消息传递相比共享内存更易实现
    * 缺点：
        1. 消息传递的实现经常采用系统调用，需要消耗更多时间以便内核介入
* 信号(Signal)：一种比较复杂的通信方式，用于通知接受进程的某个事件已经发生，比如**CTRL+C**、**CTRL+Z**、**kill -9**

* 共享内存(Shared Memory)：映射一段能被其它进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问
    * 优点：
        1. 无需复制，快捷，信息量大
        2. 仅在建立共享内存区域时需要系统调用，一旦建立共享内存，所有访问都可作为常规内存访问，无需借助内核
    * 缺点：
        1. 通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作存在同步问题
        2. 利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信
* 信号量(Semaphore)：一个计数器，可以用来控制多个进程对共享内存的访问
    * 优点：可以同步进程
    * 缺点：信号量有限
* 套接字(Socket)：可用于不同计算机间的进程通信
    * 优点：
        1. 传输数据为字节级，传输数据可自定义，数据量小效率高
        2. 传输数据时间短，性能高
        3. 适合于客户端和服务器端之间信息实时交互
        4. 可以加密，数据安全性强
    * 缺点：需要对传输的数据进行解析，转化成应用级的数据

### 线程同步的方式
* 锁机制：包括互斥锁/量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition）
    * 互斥锁/量（mutex）：提供了以排他方式防止数据结构被并发修改的方法
    * 读写锁（reader-writer lock）：允许多个线程同时读共享数据，而对写操作是互斥的
    * 自旋锁（spin lock）与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持者是否已经释放锁
    * 条件变量（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用
* 信号量机制(Semaphore)
    * 无名线程信号量
    * 命名线程信号量
* 信号机制(Signal)：类似进程间的信号处理
* 屏障（barrier）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行

*线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制*


### 进程之间私有和共享的资源
* 私有：地址空间、堆、全局变量、栈、寄存器
* 共享：代码段，公共数据，进程目录，进程 ID （这里是不是有问题？）

### 线程之间私有和共享的资源
* 私有：线程栈，寄存器，程序计数器
* 共享：堆，地址空间，全局变量，静态变量

[线程间到底共享了哪些进程资源？](https://www.eet-china.com/mp/a35347.html)


### [进程上下文切换](https://cloud.tencent.com/developer/article/1710837)

#### 进程上下文的概念

- 进程上下文是进程执行活动全过程的静态描述
- 我们把已执行过的进程指令和数据在相关寄存器与堆栈中的内容称为进程上文
- 把正在执行的指令和数据在寄存器与堆栈中的内容称为进程正文
- 把待执行的指令和数据在寄存器与堆栈中的内容称为进程下文

实际上linux内核中，进程上下文包括进程的虚拟地址空间和硬件上下文。

进程硬件上下文包含了当前cpu的一组寄存器的集合，arm64中使用task_struct结构的thread成员的cpu_context成员来描述，包括x19-x28, sp, pc等

![20220307203355](https://raw.githubusercontent.com/neicun1024/Interview/main/images_for_markdown/20220307203355.png)

#### 上下文切换详细过程
进程上下文切换主要涉及到两部分主要过程：进程地址空间切换和处理器状态切换。

- 进程地址空间切换主要是针对用户进程而言，保证了进程访问指令数据时访问的是自己的地址空间，但是进程执行的内核栈还是前一个进程的，当前执行流也还是前一个进程的，需要做切换
- 处理器状态切换应对与所有的调度单位，将前一个进程的sp, pc等寄存器的值保存到一块内存上，然后将即将执行的进程的sp, pc等寄存器的值从另一块内存中恢复到相应寄存器中，恢复sp完成了进程内核栈的切换，恢复pc完成了指令执行流的切换


#### 进程地址空间切换
![20220307204625](https://raw.githubusercontent.com/neicun1024/Interview/main/images_for_markdown/20220307204625.png)

- 进程地址空间指的是进程所拥有的虚拟地址空间，而这个地址空间是假的，是linux内核通过数据结构来描述出来的，从而使得每一个进程都感觉到自己拥有整个内存的假象，cpu访问的指令和数据最终会落实到实际的物理地址，对于进程而言通过缺页异常来分配和建立页表映射
- 进程地址空间内有进程运行的指令和数据，因此当调度器从其他进程重新切换到我的时候，为了保证当前进程访问的虚拟地址是自己的，必须切换地址空间
- 进程地址空间使用mm_struct结构体来描述，这个结构体被嵌入到进程描述符（我们通常所说的进程控制块PCB）task_struct中，mm_struct结构体将各个vma组织起来进行管理，其中有一个成员pgd至关重要，地址空间切换中最重要的是pgd的设置
- pgd中保存的是进程的页全局目录的虚拟地址，在fork（新建一个子进程）的时候，如果是创建进程，需要分配设置mm_struct，其中会分配进程页全局目录所在的页，然后将首地址赋值给pgd
- 如何实现地址空间切换？
  - 将进程的pgd虚拟地址转化为物理地址存放在ttbr0_el1（用户空间的页表基址寄存器）中，当访问用户空间地址的时候mmu会通过这个寄存器来做遍历页表获得物理地址；完成了这一步，也就完成了进程的地址空间切换，确切的说是进程的虚拟地址空间切换


#### 处理器状态（硬件上下文）切换
![20220307210119](https://raw.githubusercontent.com/neicun1024/Interview/main/images_for_markdown/20220307210119.png)

- 由于用户空间通过异常/中断进入内核空间的时候都需要保存现场，也就是保存发生异常/中断时的所有通用寄存器的值，内核会把“现场”保存到每个进程特有的进程内核栈中，并用pt_regs结构来描述，当异常/中断处理完成之后会返回用户空间，返回之前会恢复之前保存的“现场”，用户程序继续执行
- 当进程切换的时候，当前进程被时钟中断打断，将发生中断时的现场保存到进程内核栈（如：sp, lr等），然后会切换到下一个进程，当再次回切换回来的时候，返回用户空间的时候会恢复之前的现场，进程就可以继续执行（执行之前被中断打断的下一条指令，继续使用自己用户态sp），这对于用户进程来说是透明的


#### 普通用户进程、普通用户线程、内核线程切换的差别
![20220307212446](https://raw.githubusercontent.com/neicun1024/Interview/main/images_for_markdown/20220307212446.png)
内核地址空间切换的时候有一下原则：看的是进程描述符的mm_struct结构，即是成员mm:
1. 如果mm为NULL，则表示即将切换的是内核线程，不需要切换地址空间（所有任务共享内核地址空间）
2. 内核线程会借用前一个用户进程的mm，赋值到自己的active_mm（本身的mm为空），进程切换的时候就会比较前一个进程的active_mm和当前进程的mm
3. 如果前一个任务和即将切换的任务具有相同的mm成员，就是共享地址空间的线程，不需要切换地址空间

- 所有的进程线程之间进行切换都需要切换处理器状态
- 对于普通的用户进程之间进行切换需要切换地址空间
- 同一个线程组中的线程之间切换不需要切换地址空间，因为他们共享相同的地址空间
- 内核线程在上下文切换的时候不需要切换地址空间，仅仅是借用上一个进程mm_struct结构


### 用户态和内核态：

[用户态线程和内核态线程有什么区别？](http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C/14%20%20%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%EF%BC%9A%E7%94%A8%E6%88%B7%E6%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E7%BA%BF%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F.md)


### IO多路复用
[你管这破玩意叫 IO 多路复用？](https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247494866&idx=1&sn=0ebeb60dbc1fd7f9473943df7ce5fd95&chksm=c2c5967ff5b21f69030636334f6a5a7dc52c0f4de9b668f7bac15b2c1a2660ae533dd9878c7c&scene=21#wechat_redirect)


### [CTRL+C和kill的关系](http://blog.sina.com.cn/s/blog_716358dc0100lj6e.html)

CTRL+C向当前用户的进程组（process group，包括parent process，child process）中的child process的发送SIGINT signal，child process被终止后由系统再向parent process发送SIGINT signal，随之parent process被终止。所以单纯的使用kill -SIGINT是无法实现终止一个带有child process的parent process，使用kill -SIGKILL终止parent process，只会导致child process成为孤儿进程。所以如果向使用代码的方式终止带有child process的parent process，必须先将所有child process终止掉，才能让parent process终止。